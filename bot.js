/**
 * Farsi-Dutch Telegram Bot
 * Main bot file that handles all interactions
 */

// Load environment variables based on NODE_ENV
if (process.env.NODE_ENV === 'test') {
    require('dotenv').config({ path: '.env.test' });
} else {
    require('dotenv').config();
}
const TelegramBot = require('node-telegram-bot-api');
const ClaudeService = require('./services/claudeService');
const config = require('./config');
const { analyzeInput } = require('./utils/inputDetection');
const { extractWords, detectLanguage } = require('./utils/extractWords');
const { fetchWordData } = require('./utils/fetchWordData');
const { startAutoCleanup, manualCleanup } = require('./utils/autoCleanup');
const {
    formatDictionaryResponse,
    formatTranslationResponse,
    formatComprehensiveTranslation,
    formatErrorMessage,
    formatInputNotRecognizedMessage,
    getHelpMessage,
    getWelcomeMessage,
    formatQuizResponse,
    formatGrammarResponse,
    formatTestResponse,
    formatSingleTestResponse
} = require('./utils/messageFormatter');

// Import State module for saving translations (including the new filtering function)
const { loadState, saveState, addWord, addWordsFromExtraction, getRandomWords, setCurrentTest, updateTestScore, clearCurrentTest, getVocabularyStats, getNextTestWord, getWordsForOptions, startTestSession, endTestSession, markWordAsImportant, unmarkWordAsImportant, getImportantWords, isWordImportant, getSimpleWordsForTesting } = require('./lib/state');

// Environment variables validation
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;

if (!TELEGRAM_BOT_TOKEN || !CLAUDE_API_KEY) {
    console.error('‚ùå Error: Missing required environment variables!');
    console.error('Please make sure TELEGRAM_BOT_TOKEN and CLAUDE_API_KEY are set in your .env file');
    process.exit(1);
}

// Initialize services
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });
const claudeService = new ClaudeService(CLAUDE_API_KEY);
const ContentService = require('./services/contentService');
const contentService = new ContentService(claudeService);

// Constants
const MAX_INPUT_LENGTH = config.BEHAVIOR.MAX_INPUT_LENGTH;
const CHANNEL_USERNAME = config.CHANNEL_MEMBERSHIP.CHANNEL_USERNAME;
const CHANNEL_LINK = config.CHANNEL_MEMBERSHIP.CHANNEL_LINK;

// User mode storage (in production, consider using Redis or database)
const userModes = new Map(); // userId -> { mode: 'translate'|'grammar', timestamp: Date }

// Membership cache and security tracking
const membershipCache = new Map(); // userId -> { isMember: boolean, lastChecked: Date, warnings: number }

// Manual whitelist for users when API can't check (backup solution)
const manualWhitelist = new Set([741378837]); // Set of user IDs manually approved - admin is pre-approved

// Admin mode - bot has admin access to channel for real-time checking
const adminMode = true; // Bot is admin of @parsibrug channel

console.log('üöÄ AUTOMATIC MEMBERSHIP SYSTEM ENABLED');
console.log('‚úÖ Bot is admin of @parsibrug channel');
console.log('‚úÖ Real-time membership checking active');
console.log('‚úÖ Instant blocking for non-members enabled\n');

/**
 * Security function to check if membership check is needed
 * @param {number} userId - User ID to check
 * @returns {boolean} - True if check is needed
 */
function needsMembershipCheck(userId) {
    if (!config.CHANNEL_MEMBERSHIP.REQUIRED) return false;
    if (config.CHANNEL_MEMBERSHIP.SECURITY.CHECK_ON_EVERY_MESSAGE) return true;
    
    const cached = membershipCache.get(userId);
    if (!cached) return true;
    
    const cacheExpiry = config.CHANNEL_MEMBERSHIP.SECURITY.CACHE_MINUTES * 60 * 1000;
    const timeSinceCheck = Date.now() - cached.lastChecked.getTime();
    
    return timeSinceCheck > cacheExpiry;
}

/**
 * Update membership cache
 * @param {number} userId - User ID
 * @param {boolean} isMember - Membership status
 */
function updateMembershipCache(userId, isMember) {
    const existing = membershipCache.get(userId) || { warnings: 0 };
    membershipCache.set(userId, {
        isMember,
        lastChecked: new Date(),
        warnings: existing.warnings
    });
}

/**
 * Safe message sending with fallback for Markdown parsing errors
 * @param {number} chatId - Chat ID
 * @param {string} text - Message text
 * @param {Object} options - Message options
 */
async function safeSendMessage(chatId, text, options = {}) {
    try {
        // First try with original options (usually includes Markdown)
        return await bot.sendMessage(chatId, text, options);
    } catch (error) {
        if (error.code === 'ETELEGRAM' && error.response.body.description.includes("can't parse entities")) {
            console.log('‚ö†Ô∏è  Markdown parsing failed, retrying without formatting...');
            // Remove parse_mode and try again
            const safeOptions = { ...options };
            delete safeOptions.parse_mode;
            return await bot.sendMessage(chatId, text, safeOptions);
        }
        throw error; // Re-throw if it's a different error
    }
}

/**
 * Safe message editing with fallback for Markdown parsing errors
 * @param {number} chatId - Chat ID
 * @param {number} messageId - Message ID
 * @param {string} text - Message text
 * @param {Object} options - Message options
 */
async function safeEditMessage(chatId, messageId, text, options = {}) {
    try {
        // First try with original options (usually includes Markdown)
        return await bot.editMessageText(text, { 
            chat_id: chatId, 
            message_id: messageId, 
            ...options 
        });
    } catch (error) {
        if (error.code === 'ETELEGRAM' && error.response.body.description.includes("can't parse entities")) {
            console.log('‚ö†Ô∏è  Markdown parsing failed in edit, retrying without formatting...');
            // Remove parse_mode and try again
            const safeOptions = { ...options };
            delete safeOptions.parse_mode;
            return await bot.editMessageText(text, { 
                chat_id: chatId, 
                message_id: messageId, 
                ...safeOptions 
            });
        }
        throw error; // Re-throw if it's a different error
    }
}

/**
 * Safe edit message reply markup with error handling
 * @param {number} chatId - Chat ID
 * @param {number} messageId - Message ID
 * @param {Object} replyMarkup - Reply markup object
 */
async function safeEditMessageReplyMarkup(chatId, messageId, replyMarkup) {
    try {
        return await bot.editMessageReplyMarkup(replyMarkup, { 
            chat_id: chatId, 
            message_id: messageId 
        });
    } catch (error) {
        console.log('‚ö†Ô∏è  Failed to edit message reply markup:', error.message);
        // Don't throw error, just log it - the message content is still there
    }
}

/**
 * Handle user who lost membership
 * @param {number} chatId - Chat ID
 * @param {number} userId - User ID
 */
async function handleMembershipLoss(chatId, userId) {
    const cached = membershipCache.get(userId) || { warnings: 0 };
    const maxWarnings = config.CHANNEL_MEMBERSHIP.SECURITY.WARNING_COUNT;
    
    if (config.CHANNEL_MEMBERSHIP.SECURITY.WARN_BEFORE_BLOCK && cached.warnings < maxWarnings) {
        // Send warning
        cached.warnings += 1;
        membershipCache.set(userId, {
            ...cached,
            lastChecked: new Date()
        });
        
        let warningMessage;
        if (cached.warnings === maxWarnings) {
            warningMessage = config.CHANNEL_MEMBERSHIP.MESSAGES.FINAL_WARNING;
        } else {
            warningMessage = config.CHANNEL_MEMBERSHIP.MESSAGES.WARNING_MESSAGE;
        }
        
        const warningKeyboard = {
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: config.CHANNEL_MEMBERSHIP.MESSAGES.JOIN_BUTTON,
                            url: CHANNEL_LINK
                        }
                    ],
                    [
                        {
                            text: config.CHANNEL_MEMBERSHIP.MESSAGES.RECHECK_BUTTON,
                            callback_data: 'check_membership'
                        }
                    ]
                ]
            }
        };
        
        await safeSendMessage(chatId, warningMessage, {
            parse_mode: 'Markdown',
            ...warningKeyboard
        });
        
        return false; // Don't block yet, just warn
    } else {
        // Block user - send final message
        await safeSendMessage(chatId, config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_LOST, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [
                        {
                            text: config.CHANNEL_MEMBERSHIP.MESSAGES.JOIN_BUTTON,
                            url: CHANNEL_LINK
                        }
                    ],
                    [
                        {
                            text: config.CHANNEL_MEMBERSHIP.MESSAGES.RECHECK_BUTTON,
                            callback_data: 'check_membership'
                        }
                    ]
                ]
            }
        });
        
        return true; // Block user
    }
}

// Mode constants
const MODES = {
    TRANSLATE: 'translate',
    GRAMMAR: 'grammar',
    TEST: 'test'
};

// Button text constants
const BUTTON_TEXTS = {
    TRANSLATE: 'üåê ÿ™ÿ±ÿ¨ŸÖŸá',
    GRAMMAR: 'üìù ÿßÿµŸÑÿßÿ≠ ⁄Øÿ±ÿßŸÖÿ±',
    TEST: 'üìù ÿ™ÿ≥ÿ™',
    STATS: 'üìä ÿ¢ŸÖÿßÿ± ŸÖŸÜ',
    IMPORTANT_WORDS: '‚≠ê ⁄©ŸÑŸÖÿßÿ™ ŸÜÿ¥ÿßŸÜ ÿ¥ÿØŸá',
    EXIT_TEST: 'üö™ ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ™ÿ≥ÿ™',
    NEXT_TEST: '‚è≠Ô∏è ÿ≥ŸàÿßŸÑ ÿ®ÿπÿØ€å'
};

// Persistent reply keyboard configuration
const mainKeyboard = {
    reply_markup: {
        keyboard: [
            [
                { text: BUTTON_TEXTS.TRANSLATE },
                { text: BUTTON_TEXTS.GRAMMAR }
            ],
            [
                { text: BUTTON_TEXTS.TEST },
                { text: BUTTON_TEXTS.STATS }
            ],
            [
                { text: BUTTON_TEXTS.IMPORTANT_WORDS }
            ]
        ],
        resize_keyboard: true,
        one_time_keyboard: false,
        is_persistent: true
    }
};

console.log('ü§ñ Farsi-Dutch Telegram Bot is starting...');

/**
 * Check if a user is a member of the required channel with smart caching
 * @param {number} userId - User ID to check
 * @param {number} chatId - Chat ID (for sending messages)
 * @param {boolean} forceCheck - Force check even if cached
 * @returns {boolean} - True if user should have access
 */
async function isChannelMember(userId, chatId = null, forceCheck = false) {
    // If channel membership is disabled, always return true
    if (!config.CHANNEL_MEMBERSHIP.REQUIRED) {
        return true;
    }
    
    // Check manual whitelist first (for when API doesn't work)
    if (manualWhitelist.has(userId)) {
        console.log(`‚úÖ User ${userId} in manual whitelist`);
        updateMembershipCache(userId, true);
        return true;
    }
    
    // Check if we need to verify membership
    if (!forceCheck && !needsMembershipCheck(userId)) {
        const cached = membershipCache.get(userId);
        return cached ? cached.isMember : false;
    }
    
    try {
        const chatMember = await bot.getChatMember(CHANNEL_USERNAME, userId);
        const isMember = ['member', 'administrator', 'creator'].includes(chatMember.status);
        
        // Update cache
        updateMembershipCache(userId, isMember);
        
        // If user lost membership, handle it
        if (!isMember && chatId) {
            const shouldBlock = await handleMembershipLoss(chatId, userId);
            return !shouldBlock; // Return opposite of shouldBlock
        }
        
        // If user regained membership, reset warnings
        if (isMember) {
            const cached = membershipCache.get(userId);
            if (cached && cached.warnings > 0) {
                membershipCache.set(userId, {
                    ...cached,
                    warnings: 0 // Reset warnings
                });
            }
        }
        
        return isMember;
    } catch (error) {
        console.log('‚ö†Ô∏è Channel membership check failed:', error.message);
        
        // Handle different failure scenarios based on configuration
        if (error.message.includes('member list is inaccessible') || 
            error.message.includes('Forbidden') ||
            error.message.includes('user not found')) {
            
            if (config.CHANNEL_MEMBERSHIP.ON_CHECK_FAILURE === 'allow') {
                console.log('üîì Allowing access due to API limitations');
                updateMembershipCache(userId, true); // Cache as member
                return true;
            } else if (config.CHANNEL_MEMBERSHIP.ON_CHECK_FAILURE === 'block') {
                console.log('üîí Blocking access due to API limitations - showing membership message');
                updateMembershipCache(userId, false); // Cache as non-member
                
                // Show membership message when blocking due to API failure
                if (chatId) {
                    sendChannelMembershipMessage(chatId);
                }
                return false;
            }
        }
        return false;
    }
}

/**
 * Send channel membership requirement message
 * @param {number} chatId - Chat ID to send message to
 */
function sendChannelMembershipMessage(chatId) {
    const membershipMessage = config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_REQUIRED;

    const membershipKeyboard = {
        reply_markup: {
            inline_keyboard: [
                [
                    {
                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.JOIN_BUTTON,
                        url: CHANNEL_LINK
                    }
                ],
                [
                    {
                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.RECHECK_BUTTON,
                        callback_data: 'check_membership'
                    }
                ]
            ]
        }
    };

    safeSendMessage(chatId, membershipMessage, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        ...membershipKeyboard
    });
}

// Error handler for polling
bot.on('polling_error', (error) => {
    console.error('Polling error:', error);
});

// Start command handler
bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check if user is a member of the required channel
    const isMember = await isChannelMember(userId, chatId, true); // Force check on start
    
    if (!isMember) {
        sendChannelMembershipMessage(chatId);
        return;
    }
    
    const welcomeMessage = getWelcomeMessage();
    
    // Clear any existing mode for this user
    userModes.delete(userId);
    
    // Send welcome message with persistent reply keyboard
    safeSendMessage(chatId, welcomeMessage, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        ...mainKeyboard
    });
});

// Cancel/Reset command handler
bot.onText(/\/cancel/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check channel membership
    const isMember = await isChannelMember(userId, chatId);
    
    if (!isMember) {
        sendChannelMembershipMessage(chatId);
        return;
    }
    
    // Clear user's mode
    userModes.delete(userId);
    
    safeSendMessage(chatId, 'üîÑ ÿ≠ÿßŸÑÿ™ ÿ¥ŸÖÿß ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å ÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ⁄©€åÿ®Ÿàÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.', {
        parse_mode: 'Markdown',
        ...mainKeyboard
    });
});

// Help command handler
bot.onText(/\/help/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check channel membership
    const isMember = await isChannelMember(userId);
    
    if (!isMember) {
        sendChannelMembershipMessage(chatId);
        return;
    }
    
    const helpMessage = getHelpMessage();
    
    safeSendMessage(chatId, helpMessage, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        ...mainKeyboard
    });
});

// Admin cleanup command (restricted access)
bot.onText(/\/cleanup/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Restrict to bot admin (replace with your user ID)
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤', { ...mainKeyboard });
        return;
    }
    
    try {
        bot.sendMessage(chatId, 'üîÑ ÿØÿ± ÿ≠ÿßŸÑ ÿßÿ¨ÿ±ÿß€å cleanup...', { ...mainKeyboard });
        await manualCleanup(bot);
        bot.sendMessage(chatId, '‚úÖ Cleanup ÿ™⁄©ŸÖ€åŸÑ ÿ¥ÿØ', { ...mainKeyboard });
    } catch (error) {
        console.error('Manual cleanup error:', error);
        bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß ÿØÿ± cleanup', { ...mainKeyboard });
    }
});

// Content management commands (admin only)
bot.onText(/\/contentstats/, async (msg) => {
    await handleAdminContentCommands(msg, '/contentstats', []);
});

bot.onText(/\/forcepost(.*)/, async (msg, match) => {
    const args = match[1] ? match[1].trim().split(' ').filter(arg => arg) : [];
    await handleAdminContentCommands(msg, '/forcepost', args);
});

bot.onText(/\/contenttypes/, async (msg) => {
    await handleAdminContentCommands(msg, '/contenttypes', []);
});

// Admin commands for manual user management
bot.onText(/\/approve (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤');
        return;
    }
    
    const targetUserId = parseInt(match[1]);
    manualWhitelist.add(targetUserId);
    
    bot.sendMessage(chatId, `‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ${targetUserId} ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ`);
});

bot.onText(/\/remove (\d+)/, async (msg, match) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤');
        return;
    }
    
    const targetUserId = parseInt(match[1]);
    manualWhitelist.delete(targetUserId);
    membershipCache.delete(targetUserId);
    
    bot.sendMessage(chatId, `‚ùå ⁄©ÿßÿ±ÿ®ÿ± ${targetUserId} ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá ÿ≠ÿ∞ŸÅ ÿ¥ÿØ`);
});

bot.onText(/\/whitelist/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤');
        return;
    }
    
    const whitelistArray = Array.from(manualWhitelist);
    if (whitelistArray.length === 0) {
        bot.sendMessage(chatId, 'üìã ŸÑ€åÿ≥ÿ™ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá ÿÆÿßŸÑ€å ÿßÿ≥ÿ™');
    } else {
        bot.sendMessage(chatId, `üìã ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá:\n${whitelistArray.join(', ')}`);
    }
});

bot.onText(/\/userinfo/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤');
        return;
    }
    
    const user = msg.from;
    const isInWhitelist = manualWhitelist.has(userId);
    const cachedInfo = membershipCache.get(userId);
    
    let info = `üë§ **ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±:**\n`;
    info += `üÜî ID: ${userId}\n`;
    info += `üë§ Username: ${user.username || 'ŸÜÿØÿßÿ±ÿØ'}\n`;
    info += `üìù Name: ${user.first_name || ''} ${user.last_name || ''}\n`;
    info += `‚úÖ ÿØÿ± Whitelist: ${isInWhitelist ? 'ÿ®ŸÑŸá' : 'ÿÆ€åÿ±'}\n`;
    
    if (cachedInfo) {
        info += `üìã Cache Info:\n`;
        info += `  - ÿπÿ∂Ÿà: ${cachedInfo.isMember ? 'ÿ®ŸÑŸá' : 'ÿÆ€åÿ±'}\n`;
        info += `  - Ÿáÿ¥ÿØÿßÿ±Ÿáÿß: ${cachedInfo.warnings}\n`;
        info += `  - ÿ¢ÿÆÿ±€åŸÜ ÿ®ÿ±ÿ±ÿ≥€å: ${cachedInfo.lastChecked.toLocaleString()}\n`;
    }
    
    safeSendMessage(chatId, info, { parse_mode: 'Markdown' });
});

bot.onText(/\/adminhelp/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const ADMIN_USER_ID = config.ADMIN.USER_ID;
    
    if (userId !== ADMIN_USER_ID) {
        bot.sendMessage(chatId, '‚ùå ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤');
        return;
    }
    
    const helpText = `üîß **ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ ŸÖÿØ€åÿ±€åÿ™:**

**ŸÖÿØ€åÿ±€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ:**
\`/approve [user_id]\` - ÿ™ÿ£€å€åÿØ ÿØÿ≥ÿ™€å ⁄©ÿßÿ±ÿ®ÿ±
\`/remove [user_id]\` - ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿ®ÿ± ÿßÿ≤ ŸÑ€åÿ≥ÿ™ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá
\`/whitelist\` - ŸÜŸÖÿß€åÿ¥ ŸÑ€åÿ≥ÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ™ÿ£€å€åÿØ ÿ¥ÿØŸá
\`/userinfo\` - ŸÜŸÖÿß€åÿ¥ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿÆŸàÿØÿ™ÿßŸÜ

**ŸÖÿØ€åÿ±€åÿ™ ÿ≥€åÿ≥ÿ™ŸÖ:**
\`/cleanup\` - Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿØÿ≥ÿ™€å ÿ≥€åÿ≥ÿ™ŸÖ
\`/adminhelp\` - ŸÜŸÖÿß€åÿ¥ ÿß€åŸÜ ÿ±ÿßŸáŸÜŸÖÿß

**ŸÜ⁄©ÿßÿ™:**
- ŸàŸÇÿ™€å API ŸÜÿ™ŸàÿßŸÜÿØ ÿπÿ∂Ÿà€åÿ™ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜÿØÿå ÿßÿ≤ whitelist ÿØÿ≥ÿ™€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ
- ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿØÿ± whitelist ŸáŸÖ€åÿ¥Ÿá ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿØÿßÿ±ŸÜÿØ
- ÿ®ÿ±ÿß€å ÿ™ÿ£€å€åÿØ ⁄©ÿßÿ±ÿ®ÿ± ÿ¨ÿØ€åÿØ ÿßÿ≤ \`/approve [user_id]\` ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ`;

    safeSendMessage(chatId, helpText, { parse_mode: 'Markdown' });
});

// Main message handler - handles all types of messages
bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const userInput = msg.text;
    
    // Handle non-text messages (photos, stickers, voice messages, etc.)
    if (!msg.text) {
        if (msg.photo || msg.sticker || msg.voice || msg.document || msg.video) {
            bot.sendMessage(chatId, 'ŸÖŸÜ ŸÅŸÇÿ∑ Ÿæ€åÿßŸÖ‚ÄåŸáÿß€å ŸÖÿ™ŸÜ€å ÿ±ÿß Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÖ€å‚Äå⁄©ŸÜŸÖ. ŸÑÿ∑ŸÅÿßŸã ŸÖÿ™ŸÜ ÿÆŸàÿØ ÿ±ÿß ÿ™ÿß€åŸæ ⁄©ŸÜ€åÿØ Ÿà €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ⁄©€åÿ®Ÿàÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        return;
    }
    
    // Skip if message is a command (already handled by command handlers)
    if (userInput.startsWith('/')) {
        return;
    }
    
    console.log(`üì® [MAIN] Processing text from user ${userId}: "${userInput}"`);
    
    // Check channel membership before allowing any interactions
    const isMember = await isChannelMember(userId, chatId);
    
    if (!isMember) {
        console.log(`üö´ [MAIN] Access denied for user ${userId} - sending membership message`);
        sendChannelMembershipMessage(chatId);
        return;
    }
    
    console.log(`‚úÖ [MAIN] Access granted for user ${userId} - processing message`);
    
    // Handle keyboard button presses
    if (userInput === BUTTON_TEXTS.TRANSLATE) {
        handleModeSelection(chatId, userId, MODES.TRANSLATE, 'üåê ÿ≠ÿßŸÑÿ™ ÿ™ÿ±ÿ¨ŸÖŸá ŸÅÿπÿßŸÑ ÿ¥ÿØ ‚Äì Ÿæ€åÿßŸÖ ÿ®ÿπÿØ€å‚Äåÿßÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™.');
        return;
    }
    
    if (userInput === BUTTON_TEXTS.GRAMMAR) {
        handleModeSelection(chatId, userId, MODES.GRAMMAR, '‚úÖ ÿ≠ÿßŸÑÿ™ ÿßÿµŸÑÿßÿ≠ ⁄Øÿ±ÿßŸÖÿ± ŸÅÿπÿßŸÑ ÿ¥ÿØ ‚Äì Ÿæ€åÿßŸÖ ÿ®ÿπÿØ€å‚Äåÿßÿ™ ÿ±ÿß ÿ®ŸÅÿ±ÿ≥ÿ™.');
        return;
    }
    
    if (userInput === BUTTON_TEXTS.TEST) {
        // Start test immediately by calling handleTestMode
        try {
            const testResponse = await handleTestMode(chatId, userId);
            
            if (typeof testResponse === 'object' && testResponse.reply_markup) {
                await bot.sendMessage(chatId, testResponse.text, {
                    parse_mode: 'Markdown',
                    reply_markup: testResponse.reply_markup
                });
            } else {
                await bot.sendMessage(chatId, testResponse, {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        } catch (error) {
            console.error('Test button error:', error);
            bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        return;
    }
    
    if (userInput === BUTTON_TEXTS.STATS) {
        // Show user statistics
        try {
            const stats = await getVocabularyStats(chatId);
            let statsMessage = 'üìä **ÿ¢ŸÖÿßÿ± ÿØ€å⁄©ÿ¥ŸÜÿ±€å ÿ¥ŸÖÿß:**\n\n';
            
            if (stats.totalWords === 0) {
                statsMessage += 'üìö ŸáŸÜŸàÿ≤ ⁄©ŸÑŸÖŸá‚Äåÿß€å ÿ´ÿ®ÿ™ ŸÜ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.\n';
                statsMessage += 'üåê ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπÿå ÿßÿ≤ ÿØ⁄©ŸÖŸá **ÿ™ÿ±ÿ¨ŸÖŸá** ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.\n\n';
            } else {
                statsMessage += `üî§ **ÿ™ÿπÿØÿßÿØ ⁄©ŸÑŸÖÿßÿ™:** ${stats.totalWords}\n`;
                statsMessage += `ÔøΩ **⁄©ŸÑŸÖÿßÿ™ ÿ®ÿß ŸÖÿ™ÿ±ÿßÿØŸÅ:** ${stats.wordsWithSynonyms}\n`;
                statsMessage += `ÔøΩ **⁄©ŸÑŸÖÿßÿ™ ÿ®ÿß ŸÖÿ™ÿ∂ÿßÿØ:** ${stats.wordsWithAntonyms}\n`;
                statsMessage += `ÔøΩ **⁄©ŸÑŸÖÿßÿ™ ÿ®ÿß ŸÖÿ´ÿßŸÑ:** ${stats.wordsWithExamples}\n\n`;
                
                if (stats.testTotal > 0) {
                    const percentage = Math.round((stats.testScore / stats.testTotal) * 100);
                    statsMessage += `üéØ **ÿ¢ŸÖÿßÿ± ÿ™ÿ≥ÿ™:**\n`;
                    statsMessage += `‚úÖ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß€å ÿØÿ±ÿ≥ÿ™: ${stats.testScore}\n`;
                    statsMessage += `üìä ⁄©ŸÑ ÿ≥ŸàÿßŸÑÿßÿ™: ${stats.testTotal}\n`;
                    statsMessage += `üèÜ ÿØÿ±ÿµÿØ ŸÖŸàŸÅŸÇ€åÿ™: ${percentage}%\n\n`;
                }
                
                if (stats.totalWords >= 3) {
                    statsMessage += 'üéâ ÿ¢ŸÖÿßÿØŸá ÿ™ÿ≥ÿ™ Ÿáÿ≥ÿ™€åÿØ!\n';
                    statsMessage += 'üìù ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ ⁄©ŸÑŸÖÿßÿ™ÿå ÿØ⁄©ŸÖŸá **ÿ™ÿ≥ÿ™** ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.\n';
                } else {
                    const needed = 3 - stats.totalWords;
                    statsMessage += `‚ö†Ô∏è ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ÿå ${needed} ⁄©ŸÑŸÖŸá ÿØ€å⁄Øÿ± ŸÜ€åÿßÿ≤ ÿØÿßÿ±€åÿØ.\n`;
                }
            }
            
            bot.sendMessage(chatId, statsMessage, {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        } catch (error) {
            console.error('Stats error:', error);
            bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å ÿØÿ± ŸÜŸÖÿß€åÿ¥ ÿ¢ŸÖÿßÿ± Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        return;
    }
    
    if (userInput === BUTTON_TEXTS.IMPORTANT_WORDS) {
        // Show user's important words
        try {
            const importantWords = await getImportantWords(chatId);
            
            if (importantWords.length === 0) {
                bot.sendMessage(chatId, '‚≠ê **⁄©ŸÑŸÖÿßÿ™ ŸÜÿ¥ÿßŸÜ ÿ¥ÿØŸá**\n\nüìö ŸáŸÜŸàÿ≤ ⁄©ŸÑŸÖŸá‚Äåÿß€å ŸÜÿ¥ÿßŸÜ ŸÜ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.\n\nüí° **ÿ±ÿßŸáŸÜŸÖÿß€å€å:** ŸáŸÜ⁄ØÿßŸÖ ÿ™ÿ≥ÿ™ÿå ÿ±Ÿà€å ⁄©ŸÑŸÖÿßÿ™€å ⁄©Ÿá ŸÖŸáŸÖ Ÿáÿ≥ÿ™ŸÜÿØ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ ÿ™ÿß ŸÜÿ¥ÿßŸÜ ÿ¥ŸàŸÜÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            } else {
                let message = '‚≠ê **⁄©ŸÑŸÖÿßÿ™ ŸÜÿ¥ÿßŸÜ ÿ¥ÿØŸá ÿ¥ŸÖÿß:**\n\n';
                
                importantWords.forEach((word, index) => {
                    message += `${index + 1}. **${word.dutch}** ‚Üê ${word.farsi}\n`;
                });
                
                message += `\nüìä ÿ™ÿπÿØÿßÿØ: ${importantWords.length} ⁄©ŸÑŸÖŸá`;
                
                bot.sendMessage(chatId, message, {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        } catch (error) {
            console.error('Important words error:', error);
            bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ŸÜŸÖÿß€åÿ¥ ⁄©ŸÑŸÖÿßÿ™ ŸÜÿ¥ÿßŸÜ ÿ¥ÿØŸá Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        return;
    }
    
    if (userInput === BUTTON_TEXTS.EXIT_TEST) {
        // End test session and return to main menu
        try {
            await endTestSession(chatId);
            await clearCurrentTest(chatId);
            bot.sendMessage(chatId, 'üö™ **ÿßÿ≤ ÿ™ÿ≥ÿ™ ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ€åÿØ**\n\nüè† ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å ÿ®ÿ±⁄Øÿ¥ÿ™€åÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        } catch (error) {
            console.error('Exit test error:', error);
            bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                parse_mode: 'Markdown', 
                ...mainKeyboard
            });
        }
        return;
    }
    
    if (userInput === BUTTON_TEXTS.NEXT_TEST) {
        // Generate next test question
        try {
            const testResponse = await handleTestMode(chatId, userId);
            
            if (typeof testResponse === 'object' && testResponse.reply_markup) {
                await bot.sendMessage(chatId, testResponse.text, {
                    parse_mode: 'Markdown',
                    reply_markup: testResponse.reply_markup
                });
            } else {
                await bot.sendMessage(chatId, testResponse, { 
                    parse_mode: 'Markdown',
                    ...mainKeyboard 
                });
            }
        } catch (error) {
            console.error('Next test error:', error);
            bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ≥ŸàÿßŸÑ ÿ®ÿπÿØ€å Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        return;
    }
    
    // Handle user input when mode is selected
    await handleUserInput(chatId, userId, userInput);
});

/**
 * Handle mode selection from keyboard buttons
 * @param {number} chatId - Chat ID
 * @param {number} userId - User ID
 * @param {string} mode - Selected mode
 * @param {string} message - Confirmation message
 */
function handleModeSelection(chatId, userId, mode, message) {
    // Store user's selected mode
    userModes.set(userId, {
        mode: mode,
        timestamp: new Date()
    });
    
    // Send confirmation message with persistent keyboard
    bot.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        ...mainKeyboard
    });
}

/**
 * Handle actual user input when mode is selected
 * @param {number} chatId - Chat ID
 * @param {number} userId - User ID
 * @param {string} userInput - User's input text
 */
async function handleUserInput(chatId, userId, userInput) {
    // Validate input
    if (!userInput || typeof userInput !== 'string') {
        bot.sendMessage(chatId, formatErrorMessage('ŸÑÿ∑ŸÅÿßŸã €å⁄© Ÿæ€åÿßŸÖ ŸÖÿ™ŸÜ€å ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ.'), {
            parse_mode: 'Markdown',
            ...mainKeyboard
        });
        return;
    }
    
    // Check input length
    if (userInput.length > MAX_INPUT_LENGTH) {
        bot.sendMessage(chatId, formatErrorMessage(`Ÿæ€åÿßŸÖ ÿÆ€åŸÑ€å ÿ∑ŸàŸÑÿßŸÜ€åŸá. ŸÑÿ∑ŸÅÿßŸã ⁄©ŸÖÿ™ÿ± ÿßÿ≤ ${MAX_INPUT_LENGTH} ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ± ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ.`), {
            parse_mode: 'Markdown',
            ...mainKeyboard
        });
        return;
    }
    
    try {
        // Show typing indicator
        bot.sendChatAction(chatId, 'typing');
        
        // Check if user has selected a mode
        const userMode = userModes.get(userId);
        
        if (!userMode) {
            // No mode selected, ask to choose from keyboard
            bot.sendMessage(chatId, 'ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ⁄©€åÿ®Ÿàÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
            return;
        }
        
        // Check if user is in test mode and has an active test (for text-based answers)
        // Only check for test answers if user is NOT in translate or grammar mode
        const state = await loadState(chatId);
        if (state.currentTest && userMode.mode !== MODES.TRANSLATE && userMode.mode !== MODES.GRAMMAR) {
            // Handle test answer via text
            const testResult = await handleTestAnswer(chatId, userInput, state.currentTest);
            bot.sendMessage(chatId, testResult, {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
            return;
        }
        
        // Optional: Check if mode is not expired (30 minutes timeout)
        const modeAge = new Date() - userMode.timestamp;
        if (modeAge > 30 * 60 * 1000) { // 30 minutes
            userModes.delete(userId);
            bot.sendMessage(chatId, '‚è∞ ÿ≤ŸÖÿßŸÜ ÿ¨ŸÑÿ≥Ÿá ÿ¥ŸÖÿß ÿ™ŸÖÿßŸÖ ÿ¥ÿØŸá. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ⁄©€åÿ®Ÿàÿ±ÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
            return;
        }

        // Simple analysis - just check for routing logic
        const analysis = analyzeInput(userInput);
        console.log(`üîç Input analysis:`, analysis);
        
        let response;
        
        // Process based on selected mode - language is already validated above
        switch (userMode.mode) {
            case MODES.TRANSLATE:
                response = await handleTranslationMode(userInput, analysis, chatId);
                // Send normal response
                bot.sendMessage(chatId, response, {
                    parse_mode: 'Markdown',
                    disable_web_page_preview: true,
                    ...mainKeyboard
                });
                break;
            case MODES.GRAMMAR:
                response = await handleGrammarMode(userInput, analysis);
                // Send normal response
                bot.sendMessage(chatId, response, {
                    parse_mode: 'Markdown',
                    disable_web_page_preview: true,
                    ...mainKeyboard
                });
                break;
            default:
                throw new Error('Invalid mode selected');
        }
        
        // Don't send response here anymore since we're handling it in the switch statement
        return;
        
        // Keep the user mode active (don't delete it)
        // User can send another message or switch modes using keyboard
        
    } catch (error) {
        console.error('Bot Error:', error);
        
        // Don't reset user mode on error, just show error message
        let errorMessage = 'ÿÆÿ∑ÿß€å€å ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ŸÖÿß Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
        
        if (error.status === 529 || (error.error && error.error.type === 'overloaded_error')) {
            errorMessage = '‚è±Ô∏è ÿ≥ÿ±Ÿàÿ± Claude ŸÖÿ¥ÿ∫ŸàŸÑ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã €≥€∞ ÿ´ÿßŸÜ€åŸá ÿµÿ®ÿ± ⁄©ŸÜ€åÿØ Ÿà ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
        } else if (error.message && error.message.includes('API')) {
            errorMessage = 'ÿ≥ÿ±Ÿà€åÿ≥ ŸÖŸàŸÇÿ™ÿßŸã ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ⁄ÜŸÜÿØ ŸÑÿ≠ÿ∏Ÿá ÿØ€å⁄Øÿ± ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
        } else if (error.status >= 500) {
            errorMessage = 'ŸÖÿ¥⁄©ŸÑ ÿ≥ÿ±Ÿàÿ±. ŸÑÿ∑ŸÅÿßŸã ⁄ÜŸÜÿØ ÿØŸÇ€åŸÇŸá ÿØ€å⁄Øÿ± ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
        }
        
        bot.sendMessage(chatId, formatErrorMessage(errorMessage), {
            parse_mode: 'Markdown',
            ...mainKeyboard
        });
    }
}

// Callback query handler for inline keyboard buttons
bot.on('callback_query', async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;
    
    console.log('Callback received:', data);
    
    try {
        // Answer callback query to remove loading state
        await bot.answerCallbackQuery(callbackQuery.id);
        
        // Allow membership check without membership requirement
        if (data === 'check_membership') {
            const isMember = await isChannelMember(userId, chatId, true); // Force check
            
            if (isMember) {
                // User is now a member, show welcome message
                const welcomeMessage = getWelcomeMessage();
                
                // Clear any existing mode for this user
                userModes.delete(userId);
                
                // Reset warnings when user rejoins
                const cached = membershipCache.get(userId);
                if (cached) {
                    membershipCache.set(userId, {
                        ...cached,
                        warnings: 0
                    });
                }
                
                try {
                    await safeEditMessage(chatId, callbackQuery.message.message_id, config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_VERIFIED, {
                        parse_mode: 'Markdown'
                    });
                } catch (editError) {
                    // If message edit fails (e.g., same content), just send a new message
                    console.log('Message edit failed, sending new message instead:', editError.message);
                    await safeSendMessage(chatId, config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_VERIFIED, {
                        parse_mode: 'Markdown'
                    });
                }
                
                // Send welcome message with main keyboard
                await safeSendMessage(chatId, welcomeMessage, {
                    parse_mode: 'Markdown',
                    disable_web_page_preview: true,
                    ...mainKeyboard
                });
            } else {
                // User is still not a member
                try {
                    await safeEditMessage(chatId, callbackQuery.message.message_id, config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_FAILED, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    {
                                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.JOIN_BUTTON,
                                        url: CHANNEL_LINK
                                    }
                                ],
                                [
                                    {
                                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.RECHECK_BUTTON,
                                        callback_data: 'check_membership'
                                    }
                                ]
                            ]
                        }
                    });
                } catch (editError) {
                    // If message edit fails, send a new message
                    console.log('Message edit failed, sending new message instead:', editError.message);
                    await bot.sendMessage(chatId, config.CHANNEL_MEMBERSHIP.MESSAGES.MEMBERSHIP_FAILED, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    {
                                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.JOIN_BUTTON,
                                        url: CHANNEL_LINK
                                    }
                                ],
                                [
                                    {
                                        text: config.CHANNEL_MEMBERSHIP.MESSAGES.RECHECK_BUTTON,
                                        callback_data: 'check_membership'
                                    }
                                ]
                            ]
                        }
                    });
                }
            }
            return;
        }
        
        // Check channel membership for all other callback queries
        const isMember = await isChannelMember(userId, chatId);
        
        if (!isMember) {
            return; // User was already notified by isChannelMember function
        }
        
        // Handle test answers
        if (data.startsWith('test_answer_')) {
            const parts = data.split('_');
            const selectedIndex = parseInt(parts[2]);
            const testId = parts[3];
            
            // Load current test from state
            const state = await loadState(chatId);
            if (state.currentTest && state.currentTest.id === testId) {
                const selectedOption = state.currentTest.options[selectedIndex];
                const testResult = await handleTestCallbackAnswer(chatId, selectedOption, state.currentTest);
                
                // Edit the message to show result with new keyboard
                await safeEditMessage(chatId, callbackQuery.message.message_id, testResult.text, {
                    parse_mode: 'Markdown',
                    reply_markup: testResult.reply_markup
                });
            } else {
                await bot.sendMessage(chatId, 'ÿß€åŸÜ ÿ™ÿ≥ÿ™ ŸÖŸÜŸÇÿ∂€å ÿ¥ÿØŸá. ŸÑÿ∑ŸÅÿßŸã ÿ™ÿ≥ÿ™ ÿ¨ÿØ€åÿØ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle next test request from inline button
        if (data === 'next_test') {
            try {
                const testResponse = await handleTestMode(chatId, userId);
                if (typeof testResponse === 'object' && testResponse.reply_markup) {
                    // Edit current message with new test
                    await safeEditMessage(chatId, callbackQuery.message.message_id, testResponse.text, {
                        parse_mode: 'Markdown',
                        reply_markup: testResponse.reply_markup
                    });
                } else {
                    // Edit message and send main keyboard
                    await safeEditMessage(chatId, callbackQuery.message.message_id, testResponse, {
                        parse_mode: 'Markdown'
                    });
                    
                    await bot.sendMessage(chatId, 'üè† ÿ®ÿ±⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å:', {
                        parse_mode: 'Markdown',
                        ...mainKeyboard
                    });
                }
            } catch (error) {
                console.error('Next test error:', error);
                await bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ≥ŸàÿßŸÑ ÿ®ÿπÿØ€å Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle exit test request from inline button
        if (data === 'exit_test') {
            try {
                await endTestSession(chatId);
                await clearCurrentTest(chatId);
                
                // Edit current message
                await safeEditMessage(chatId, callbackQuery.message.message_id, 'üö™ **ÿßÿ≤ ÿ™ÿ≥ÿ™ ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ€åÿØ**\n\nüè† ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å ÿ®ÿ±⁄Øÿ¥ÿ™€åÿØ.', {
                    parse_mode: 'Markdown'
                });
                
                // Send main keyboard
                await bot.sendMessage(chatId, 'üí° ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ÿ≥ÿ™ ÿ¥ÿ±Ÿàÿπ ⁄©ŸÜ€åÿØ €åÿß ÿßÿ≤ ÿßŸÖ⁄©ÿßŸÜÿßÿ™ ÿØ€å⁄Øÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ:', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            } catch (error) {
                console.error('Exit test error:', error);
                await bot.sendMessage(chatId, '‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle new test request
        if (data === 'start_new_test') {
            try {
                const testResponse = await handleTestMode(chatId, userId);
                if (typeof testResponse === 'object' && testResponse.reply_markup) {
                    await bot.sendMessage(chatId, testResponse.text, {
                        parse_mode: 'Markdown',
                        reply_markup: testResponse.reply_markup
                    });
                } else {
                    await bot.sendMessage(chatId, testResponse, {
                        parse_mode: 'Markdown',
                        ...mainKeyboard
                    });
                }
            } catch (error) {
                console.error('New test error:', error);
                await bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle word marking request
        if (data.startsWith('mark_word_')) {
            const wordId = data.replace('mark_word_', '');
            
            try {
                const state = await loadState(chatId);
                const word = state.words.find(w => w.id === wordId);
                
                if (word) {
                    const isAlreadyMarked = await isWordImportant(chatId, wordId);
                    
                    if (isAlreadyMarked) {
                        await unmarkWordAsImportant(chatId, wordId);
                        
                        // Update button text to show unmarked state
                        const updatedKeyboard = {
                            inline_keyboard: [
                                [
                                    {
                                        text: '‚≠ê ŸÜÿ¥ÿßŸÜ ⁄©ÿ±ÿØŸÜ ⁄©ŸÑŸÖŸá',
                                        callback_data: `mark_word_${wordId}`
                                    }
                                ],
                                [
                                    {
                                        text: 'üîÑ ÿ¢ŸÖÿßÿØŸá ÿ™ÿ≥ÿ™ ÿ®ÿπÿØ€åÿü',
                                        callback_data: 'start_new_test'
                                    }
                                ]
                            ]
                        };
                        
                        // Update the message with new button text
                        await safeEditMessageReplyMarkup(chatId, callbackQuery.message.message_id, updatedKeyboard);
                        
                        await bot.answerCallbackQuery(callbackQuery.id, {
                            text: `‚úÖ ⁄©ŸÑŸÖŸá "${word.dutch}" ÿßÿ≤ ⁄©ŸÑŸÖÿßÿ™ ŸÜÿ¥ÿßŸÜ ÿ¥ÿØŸá ÿ≠ÿ∞ŸÅ ÿ¥ÿØ`,
                            show_alert: true
                        });
                    } else {
                        await markWordAsImportant(chatId, wordId);
                        
                        // Update button text to show marked state
                        const updatedKeyboard = {
                            inline_keyboard: [
                                [
                                    {
                                        text: '‚≠ê ŸÜÿ¥ÿßŸÜ ÿ¥ÿØ',
                                        callback_data: `mark_word_${wordId}`
                                    }
                                ],
                                [
                                    {
                                        text: 'üîÑ ÿ¢ŸÖÿßÿØŸá ÿ™ÿ≥ÿ™ ÿ®ÿπÿØ€åÿü',
                                        callback_data: 'start_new_test'
                                    }
                                ]
                            ]
                        };
                        
                        // Update the message with new button text
                        await safeEditMessageReplyMarkup(chatId, callbackQuery.message.message_id, updatedKeyboard);
                        
                        await bot.answerCallbackQuery(callbackQuery.id, {
                            text: `‚≠ê ⁄©ŸÑŸÖŸá "${word.dutch}" ŸÜÿ¥ÿßŸÜ ÿ¥ÿØ Ÿà ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ⁄©ŸÑŸÖÿßÿ™ ŸÖŸáŸÖ ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ`,
                            show_alert: true
                        });
                    }
                } else {
                    await bot.answerCallbackQuery(callbackQuery.id, {
                        text: '‚ùå ⁄©ŸÑŸÖŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ',
                        show_alert: true
                    });
                }
            } catch (error) {
                console.error('Mark word error:', error);
                await bot.answerCallbackQuery(callbackQuery.id, {
                    text: '‚ùå ÿÆÿ∑ÿß ÿØÿ± ŸÜÿ¥ÿßŸÜ ⁄©ÿ±ÿØŸÜ ⁄©ŸÑŸÖŸá',
                    show_alert: true
                });
            }
        }
        
        // Handle vocabulary test request
        if (data === 'test_vocab') {
            try {
                const testResponse = await handleTestMode(chatId, userId);
                
                if (typeof testResponse === 'object' && testResponse.reply_markup) {
                    await bot.sendMessage(chatId, testResponse.text, {
                        parse_mode: 'Markdown',
                        reply_markup: testResponse.reply_markup
                    });
                } else {
                    await bot.sendMessage(chatId, testResponse, {
                        parse_mode: 'Markdown',
                        ...mainKeyboard
                    });
                }
                
            } catch (error) {
                console.error('‚ùå Vocabulary test error:', error);
                await bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle show vocabulary request
        if (data === 'show_vocab') {
            try {
                const state = await loadState(chatId);
                const stats = await getVocabularyStats(chatId);
                
                if (stats.totalWords === 0) {
                    await bot.sendMessage(chatId, 'üìö ŸáŸÜŸàÿ≤ Ÿá€å⁄Ü ⁄©ŸÑŸÖŸá‚Äåÿß€å ÿØÿ± ŸÖÿ¨ŸÖŸàÿπŸá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ŸÜ€åÿ≥ÿ™.\n\nüí° ÿ®ÿ±ÿß€å ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ⁄©ŸÑŸÖÿßÿ™ÿå ŸÖÿ™ŸÜ ŸáŸÑŸÜÿØ€å ÿ®ÿ±ÿß€å ÿ™ÿ±ÿ¨ŸÖŸá ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.', {
                        parse_mode: 'Markdown',
                        ...mainKeyboard
                    });
                } else {
                    // Show first 10 words as preview
                    const recentWords = state.words.slice(-10).reverse();
                    let vocabList = `üìä **ÿ¢ŸÖÿßÿ± Ÿàÿß⁄ò⁄ØÿßŸÜ:**\nüî¢ ÿ™ÿπÿØÿßÿØ ⁄©ŸÑ: ${stats.totalWords} ⁄©ŸÑŸÖŸá\n\n`;
                    vocabList += `üìù **ÿ¢ÿÆÿ±€åŸÜ ⁄©ŸÑŸÖÿßÿ™:**\n`;
                    
                    recentWords.forEach((word, index) => {
                        vocabList += `${index + 1}. ${word.dutch} ‚Üí ${word.farsi}\n`;
                    });
                    
                    if (stats.totalWords > 10) {
                        vocabList += `\n... Ÿà ${stats.totalWords - 10} ⁄©ŸÑŸÖŸá ÿØ€å⁄Øÿ±`;
                    }
                    
                    await bot.sendMessage(chatId, vocabList, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    {text: 'üß™ ÿ™ÿ≥ÿ™ Ÿàÿß⁄ò⁄ØÿßŸÜ', callback_data: 'test_vocab'},
                                    {text: 'üè† ŸÖŸÜŸà€å ÿßÿµŸÑ€å', callback_data: 'main_menu'}
                                ]
                            ]
                        }
                    });
                }
            } catch (error) {
                console.error('Show vocabulary error:', error);
                await bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å ÿØÿ± ŸÜŸÖÿß€åÿ¥ Ÿàÿß⁄ò⁄ØÿßŸÜ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.', {
                    parse_mode: 'Markdown',
                    ...mainKeyboard
                });
            }
        }
        
        // Handle main menu request
        if (data === 'main_menu') {
            await bot.sendMessage(chatId, 'ÿ≥ŸÑÿßŸÖ! üëã\n\nŸÖŸÜ ÿ±ÿ®ÿßÿ™ ÿ™ÿ±ÿ¨ŸÖŸá ŸÅÿßÿ±ÿ≥€å-ŸáŸÑŸÜÿØ€å Ÿáÿ≥ÿ™ŸÖ. ŸÖ€å‚Äåÿ™ŸàŸÜŸÖ:\n\nüî§ ŸÖÿ™ŸÜ ŸáŸÑŸÜÿØ€å €åÿß ŸÅÿßÿ±ÿ≥€å ÿ±Ÿà ÿ™ÿ±ÿ¨ŸÖŸá ⁄©ŸÜŸÖ\nüìù ⁄Øÿ±ÿßŸÖÿ± ŸÖÿ™ŸÜ‚Äåÿ™ŸàŸÜ ÿ±Ÿà ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜŸÖ\nüß™ ÿ™ÿ≥ÿ™ Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ®ÿ≥ÿßÿ≤ŸÖ\n\nŸÅŸÇÿ∑ ⁄©ÿßŸÅ€åŸá ŸÖÿ™ŸÜÿ™ŸàŸÜ ÿ±Ÿà ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ!', {
                parse_mode: 'Markdown',
                ...mainKeyboard
            });
        }
        
    } catch (error) {
        console.error('Callback query error:', error);
        await bot.sendMessage(chatId, 'ÿÆÿ∑ÿß€å€å Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.', {
            parse_mode: 'Markdown',
            ...mainKeyboard
        });
    }
});

/**
 * Extract vocabulary items from comprehensive translation analysis
 * @param {string} analysis - The comprehensive analysis text
 * @param {string} detectedLanguage - 'persian' or 'dutch'
 * @returns {Array} - Array of {dutch, farsi} vocabulary objects
 */
function extractVocabularyFromAnalysis(analysis, detectedLanguage) {
    const vocabularyItems = [];
    
    try {
        // Look for vocabulary section in the analysis
        const lines = analysis.split('\n');
        let inVocabSection = false;
        
        for (const line of lines) {
            // Check if we're entering the vocabulary section
            if (line.includes('üìö Ÿàÿß⁄ò⁄ØÿßŸÜ ŸÖŸáŸÖ') || line.includes('üìö Belangrijke woorden')) {
                inVocabSection = true;
                continue;
            }
            
            // Check if we're leaving the vocabulary section
            if (inVocabSection && (line.includes('[3]') || line.includes('üí° ŸÖŸÜÿ∏Ÿàÿ±') || line.includes('üí° Betekenis'))) {
                break;
            }
            
            // Extract vocabulary items
            if (inVocabSection && line.includes(' = ')) {
                const parts = line.split(' = ');
                if (parts.length === 2) {
                    const word = parts[0].trim();
                    const meaning = parts[1].trim();
                    
                    if (word && meaning) {
                        if (detectedLanguage === 'persian') {
                            // Persian input text: farsi_word = dutch_meaning
                            vocabularyItems.push({
                                dutch: meaning,
                                farsi: word
                            });
                        } else {
                            // Dutch input text: dutch_word = farsi_meaning
                            vocabularyItems.push({
                                dutch: word,
                                farsi: meaning
                            });
                        }
                    }
                }
            }
        }
    } catch (error) {
        console.error('Error extracting vocabulary:', error);
    }
    
    return vocabularyItems;
}

// Helper functions for different modes
/**
 * Handle translation mode
 * @param {string} userInput - User's input text
 * @param {object} analysis - Pre-computed analysis from analyzeInput
 * @param {string} chatId - Chat ID for saving messages
 * @returns {Promise<string>} - Formatted response
 */
async function handleTranslationMode(userInput, analysis, chatId) {
    console.log(`üåê Translation request: "${userInput}"`);
    
    let response;
    let detectedLanguage;
    
    if (analysis.inputType === 'dictionary') {
        // Single word - provide dictionary definition
        detectedLanguage = await claudeService.detectLanguage(userInput);
        const dictionaryData = await claudeService.getDictionaryDefinition(userInput, detectedLanguage);
        response = formatDictionaryResponse(dictionaryData);
        
        // Save the main word entry AND synonyms/antonyms (NOT the examples)
        // Examples are just for display, not for vocabulary building
        try {
            console.log(`ÔøΩ Saving main dictionary word: "${userInput}" ‚Üí "${dictionaryData.translation || dictionaryData.dutchMeaning || dictionaryData.farsiMeaning || ''}"`);
            
            // Extract the actual translation from the dictionary data
            let translation = '';
            if (detectedLanguage === 'persian') {
                translation = dictionaryData.dutchMeaning || dictionaryData.translation || '';
                if (translation && translation.trim()) {
                    await addWord(chatId, translation, userInput);
                    console.log(`‚úÖ Dictionary entry saved: ${userInput} ‚Üí ${translation}`);
                    
                    // Show success message to user
                    await bot.sendMessage(chatId, `üìö ⁄©ŸÑŸÖŸá ¬´${userInput}¬ª ÿ®ÿß ÿ™ÿ±ÿ¨ŸÖŸá ¬´${translation}¬ª ÿ®Ÿá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!`);
                } else {
                    console.log(`‚ö†Ô∏è No translation found for Persian word: ${userInput}`);
                }
            } else {
                translation = dictionaryData.farsiMeaning || dictionaryData.translation || '';
                if (translation && translation.trim()) {
                    await addWord(chatId, userInput, translation);
                    console.log(`‚úÖ Dictionary entry saved: ${userInput} ‚Üí ${translation}`);
                    
                    // Show success message to user
                    await bot.sendMessage(chatId, `üìö ⁄©ŸÑŸÖŸá ¬´${userInput}¬ª ÿ®ÿß ÿ™ÿ±ÿ¨ŸÖŸá ¬´${translation}¬ª ÿ®Ÿá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!`);
                } else {
                    console.log(`‚ö†Ô∏è No translation found for Dutch word: ${userInput}`);
                }
            }
        } catch (error) {
            console.error('‚ùå Error saving dictionary entry:', error);
        }
    } else {
        // Sentence or phrase - use comprehensive translation with vocabulary analysis
        detectedLanguage = await claudeService.detectLanguage(userInput);
        const comprehensiveAnalysis = await claudeService.getComprehensiveTranslation(userInput, detectedLanguage);
        response = formatComprehensiveTranslation(comprehensiveAnalysis, detectedLanguage);
        
        // Extract simple translation for saving (first line of comprehensive analysis)
        let simpleTranslation = userInput; // fallback
        try {
            // Try to extract translation from comprehensive analysis
            const lines = comprehensiveAnalysis.split('\n');
            const translationLine = lines.find(line => 
                line.includes('€åÿπŸÜ€å:') || line.includes('betekent:') || line.includes('¬´') || line.includes('"')
            );
            if (translationLine) {
                // Extract text between quotes or after colon
                const match = translationLine.match(/[¬´"](.*?)[¬ª"]/);
                if (match) {
                    simpleTranslation = match[1];
                } else {
                    const colonMatch = translationLine.split(':').slice(1).join(':').trim();
                    if (colonMatch) simpleTranslation = colonMatch.replace(/[¬´¬ª"]/g, '').trim();
                }
            }
        } catch (e) {
            console.log('Could not extract simple translation for saving');
        }
        
        // Extract and save important vocabulary from comprehensive translation
        try {
            console.log('üìö Extracting important vocabulary from comprehensive translation...');
            
            // Extract vocabulary section from the comprehensive analysis
            const vocabSection = extractVocabularyFromAnalysis(comprehensiveAnalysis, detectedLanguage);
            
            if (vocabSection && vocabSection.length > 0) {
                console.log(`üîç Found ${vocabSection.length} important vocabulary items`);
                
                for (const vocabItem of vocabSection) {
                    if (vocabItem.dutch && vocabItem.farsi) {
                        await addWord(chatId, vocabItem.dutch, vocabItem.farsi);
                        console.log(`‚úÖ Important vocab saved: ${vocabItem.dutch} ‚Üí ${vocabItem.farsi}`);
                    }
                }
                
                // Show success message for vocabulary extracted from text
                if (vocabSection.length > 0) {
                    await bot.sendMessage(chatId, `üìö ${vocabSection.length} ⁄©ŸÑŸÖŸá ŸÖŸáŸÖ ÿßÿ≤ ŸÖÿ™ŸÜ ÿ®Ÿá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!`);
                }
            } else {
                console.log('‚ÑπÔ∏è No important vocabulary found in comprehensive analysis');
            }
            
        } catch (error) {
            console.error('‚ùå Error extracting vocabulary from comprehensive translation:', error);
        }
        
        // Save the main translation as a word/phrase if it's simple enough
        try {
            console.log('ÔøΩ Saving main translation for vocabulary');
            
            // Simple approach: save the main translation first if input is word-like
            const userWords = userInput.trim().split(/\s+/);
            const translationWords = simpleTranslation.trim().split(/\s+/);
            
            // Save if input is reasonably short (1-5 words)
            if (userWords.length <= 5) {
                // For sentences/phrases, try to get the actual translation from Claude
                console.log('üîç Getting translation from Claude for word saving...');
                const actualTranslation = await claudeService.translateText(userInput, detectedLanguage);
                
                if (actualTranslation && actualTranslation.trim() && actualTranslation !== userInput) {
                    const translationWords = actualTranslation.trim().split(/\s+/);
                    
                    // Make sure translation is also reasonably short
                    if (translationWords.length <= 8) {
                        if (detectedLanguage === 'persian') {
                            await addWord(chatId, actualTranslation, userInput);
                            console.log(`‚úÖ Saved main translation: ${userInput} ‚Üí ${actualTranslation}`);
                            
                            // Show success message to user
                            await bot.sendMessage(chatId, `üìö ÿπÿ®ÿßÿ±ÿ™ ¬´${userInput}¬ª ÿ®ÿß ÿ™ÿ±ÿ¨ŸÖŸá ¬´${actualTranslation}¬ª ÿ®Ÿá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!`);
                        } else {
                            await addWord(chatId, userInput, actualTranslation);
                            console.log(`‚úÖ Saved main translation: ${userInput} ‚Üí ${actualTranslation}`);
                            
                            // Show success message to user
                            await bot.sendMessage(chatId, `üìö ÿπÿ®ÿßÿ±ÿ™ ¬´${userInput}¬ª ÿ®ÿß ÿ™ÿ±ÿ¨ŸÖŸá ¬´${actualTranslation}¬ª ÿ®Ÿá Ÿàÿß⁄ò⁄ØÿßŸÜ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ!`);
                        }
                    } else {
                        console.log(`‚ÑπÔ∏è Skipping main translation save - translation too long (${translationWords.length} words)`);
                    }
                } else {
                    console.log(`‚ÑπÔ∏è Skipping main translation save - no valid translation obtained`);
                }
            } else {
                console.log(`‚ÑπÔ∏è Skipping main translation save - input too long (${userWords.length} words)`);
            }
            
        } catch (error) {
            console.error('‚ùå Error in main translation saving:', error);
        }
    }
    
    return response;
}

/**
 * Handle grammar correction mode
 * @param {string} userInput - User's input text
 * @param {object} analysis - Pre-computed analysis from analyzeInput
 * @returns {Promise<string>} - Formatted grammar correction
 */
async function handleGrammarMode(userInput, analysis) {
    console.log(`‚úÖ Grammar correction request: "${userInput}"`);
    
    // Check text length limits (50 words or 300 characters max)
    const wordCount = userInput.trim().split(/\s+/).length;
    const charCount = userInput.length;
    
    if (wordCount > 50) {
        return `‚ö†Ô∏è **ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ∑ŸàŸÑ ŸÖÿ™ŸÜ**\n\nŸÑÿ∑ŸÅÿßŸã ŸÖÿ™ŸÜ ⁄©Ÿàÿ™ÿßŸá‚Äåÿ™ÿ±€å ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ:\n‚Ä¢ ÿ≠ÿØÿß⁄©ÿ´ÿ± **50 ⁄©ŸÑŸÖŸá** ŸÖÿ¨ÿßÿ≤ ÿßÿ≥ÿ™\n‚Ä¢ ŸÖÿ™ŸÜ ÿ¥ŸÖÿß: **${wordCount} ⁄©ŸÑŸÖŸá**\n\nüí° ŸÖÿ™ŸÜ ⁄©Ÿàÿ™ÿßŸá‚Äåÿ™ÿ± ÿ®ÿ±ÿß€å ÿßÿµŸÑÿßÿ≠ ÿ®Ÿáÿ™ÿ± ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.`;
    }
    
    if (charCount > 300) {
        return `‚ö†Ô∏è **ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ∑ŸàŸÑ ŸÖÿ™ŸÜ**\n\nŸÑÿ∑ŸÅÿßŸã ŸÖÿ™ŸÜ ⁄©Ÿàÿ™ÿßŸá‚Äåÿ™ÿ±€å ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ:\n‚Ä¢ ÿ≠ÿØÿß⁄©ÿ´ÿ± **300 ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ±** ŸÖÿ¨ÿßÿ≤ ÿßÿ≥ÿ™\n‚Ä¢ ŸÖÿ™ŸÜ ÿ¥ŸÖÿß: **${charCount} ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ±**\n\nüí° ŸÖÿ™ŸÜ ⁄©Ÿàÿ™ÿßŸá‚Äåÿ™ÿ± ÿ®ÿ±ÿß€å ÿßÿµŸÑÿßÿ≠ ÿ®Ÿáÿ™ÿ± ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.`;
    }
    
    // Detect language and validate it's Dutch only
    const detectedLanguage = await claudeService.detectLanguage(userInput);
    console.log(`üîç Language detected for grammar correction: ${detectedLanguage}`);
    
    if (detectedLanguage !== 'dutch') {
        return `‚ö†Ô∏è **ŸÅŸÇÿ∑ ŸÖÿ™ŸÜ ŸáŸÑŸÜÿØ€å ŸÇÿßÿ®ŸÑ ÿßÿµŸÑÿßÿ≠ ÿßÿ≥ÿ™**\n\nÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿßÿµŸÑÿßÿ≠ ⁄Øÿ±ÿßŸÖÿ± ŸÖÿ™ŸàŸÜ ŸáŸÑŸÜÿØ€å ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿßÿ≥ÿ™.\n\n‚Ä¢ ÿ≤ÿ®ÿßŸÜ ÿ™ÿ¥ÿÆ€åÿµ ÿØÿßÿØŸá ÿ¥ÿØŸá: **${detectedLanguage === 'persian' ? 'ŸÅÿßÿ±ÿ≥€å' : 'ŸÜÿßŸÖÿ¥ÿÆÿµ'}**\n‚Ä¢ ÿ®ÿ±ÿß€å ÿßÿµŸÑÿßÿ≠ ⁄Øÿ±ÿßŸÖÿ±ÿå ŸÑÿ∑ŸÅÿßŸã ŸÖÿ™ŸÜ ŸáŸÑŸÜÿØ€å ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ\n\nüí° ÿ®ÿ±ÿß€å ÿ™ÿ±ÿ¨ŸÖŸá ÿßÿ≤ ÿØ⁄©ŸÖŸá "ÿ™ÿ±ÿ¨ŸÖŸá" ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.`;
    }
    
    try {
        // Request grammar correction from Claude
        const correction = await claudeService.correctGrammar(userInput, detectedLanguage);
        return formatGrammarResponse(correction, detectedLanguage);
    } catch (error) {
        console.error('Grammar correction error:', error);
        return `‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ÿßÿµŸÑÿßÿ≠ ⁄Øÿ±ÿßŸÖÿ± ÿ±ÿÆ ÿØÿßÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.`;
    }
}

/**
 * Handle test mode - generate word-focused tests from user's vocabulary
 * @param {string} chatId - Chat ID
 * @param {string} userId - User ID
 * @returns {Promise<string>} - Formatted test response
 */
async function handleTestMode(chatId, userId) {
    console.log(`üìù Test generation request for user: ${userId}`);
    
    try {
        // Load user's vocabulary from state
        const state = await loadState(chatId);
        
        if (!state.words || state.words.length === 0) {
            return 'üìö **ŸáŸÜŸàÿ≤ ⁄©ŸÑŸÖŸá‚Äåÿß€å ÿØÿ± ÿØ€å⁄©ÿ¥ŸÜÿ±€å ÿ¥ŸÖÿß ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá!**\n\n' +
                   'üî§ ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ÿ™ÿ≥ÿ™ÿå ÿßÿ®ÿ™ÿØÿß ⁄©ŸÑŸÖÿßÿ™ ŸáŸÑŸÜÿØ€å ÿ™ÿ±ÿ¨ŸÖŸá ⁄©ŸÜ€åÿØ:\n\n' +
                   '1Ô∏è‚É£ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá **üåê ÿ™ÿ±ÿ¨ŸÖŸá** ÿ®ÿ≤ŸÜ€åÿØ\n' +
                   '2Ô∏è‚É£ ⁄©ŸÑŸÖŸá ŸáŸÑŸÜÿØ€å ÿ®ŸÜŸà€åÿ≥€åÿØ (ŸÖÿ´ŸÑ: huisÿå boekÿå water)\n' +
                   '3Ô∏è‚É£ ÿ≥Ÿæÿ≥ ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ÿ≥ÿ™ ÿ±ÿß ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ\n\n' +
                   'üí° ÿ≠ÿØÿßŸÇŸÑ 3 ⁄©ŸÑŸÖŸá ŸÜ€åÿßÿ≤ ÿßÿ≥ÿ™ ÿ™ÿß ÿ®ÿ™ŸàÿßŸÜ€åÿØ ÿ™ÿ≥ÿ™ ÿ®ÿØŸá€åÿØ.';
        }
        
        // Filter words to get only simple vocabulary suitable for testing
        const simpleWords = getSimpleWordsForTesting(state.words);
        const totalWords = state.words.length;
        const simpleWordsCount = simpleWords.length;
        
        if (simpleWordsCount === 0) {
            return `ÔøΩ **ÿ¥ŸÖÿß ${totalWords} ⁄©ŸÑŸÖŸá ÿØÿ± ÿØ€å⁄©ÿ¥ŸÜÿ±€å ÿØÿßÿ±€åÿØ ÿßŸÖÿß Ÿá€å⁄Ü‚Äå⁄©ÿØÿßŸÖ ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ ŸÖŸÜÿßÿ≥ÿ® ŸÜ€åÿ≥ÿ™ŸÜÿØ!**\n\n` +
                   `üéØ ⁄©ŸÑŸÖÿßÿ™ ŸÖŸàÿ¨ŸàÿØ ÿ¥ŸÖÿß ÿß⁄©ÿ´ÿ±ÿßŸã ÿ¨ŸÖŸÑÿßÿ™ €åÿß ÿπÿ®ÿßÿ±ÿßÿ™ Ÿæ€å⁄Ü€åÿØŸá Ÿáÿ≥ÿ™ŸÜÿØ.\n\n` +
                   `üî§ ŸÑÿ∑ŸÅÿßŸã ⁄©ŸÑŸÖÿßÿ™ ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±€å ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ€åÿØ:\n` +
                   `‚Ä¢ ⁄©ŸÑŸÖÿßÿ™ ŸÅÿßÿ±ÿ≥€å: ÿÆÿßŸÜŸáÿå ⁄©ÿ™ÿßÿ®ÿå ÿ¢ÿ®ÿå ÿ∫ÿ∞ÿß\n` +
                   `‚Ä¢ ⁄©ŸÑŸÖÿßÿ™ ŸáŸÑŸÜÿØ€å: huisÿå boekÿå waterÿå eten\n\n` +
                   `‚ú® ⁄©ŸÑŸÖÿßÿ™ ÿ≥ÿßÿØŸá ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™‚ÄåŸáÿß€å ÿ®Ÿáÿ™ÿ± ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ!`;
        }
        
        if (simpleWordsCount < 3) {
            return `üìä **ÿ¥ŸÖÿß ${totalWords} ⁄©ŸÑŸÖŸá ⁄©ŸÑ ÿØÿßÿ±€åÿØÿå ${simpleWordsCount} ŸÖŸÜÿßÿ≥ÿ® ÿ™ÿ≥ÿ™**\n\n` +
                   `üéØ ÿ®ÿ±ÿß€å ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ÿå ÿ≠ÿØÿßŸÇŸÑ 3 ⁄©ŸÑŸÖŸá ÿ≥ÿßÿØŸá ŸÜ€åÿßÿ≤ ÿßÿ≥ÿ™.\n\n` +
                   `üî§ ⁄©ŸÑŸÖÿßÿ™ ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±€å ÿ®ÿß ÿØ⁄©ŸÖŸá **üåê ÿ™ÿ±ÿ¨ŸÖŸá** ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ€åÿØ:\n` +
                   `‚Ä¢ ⁄©ŸÑŸÖÿßÿ™ ⁄©Ÿàÿ™ÿßŸá (1-2 ⁄©ŸÑŸÖŸá)\n` +
                   `‚Ä¢ ÿ®ÿØŸàŸÜ ŸÜŸÇÿ∑Ÿá‚Äå⁄Øÿ∞ÿßÿ±€å €åÿß ÿ¨ŸÖŸÑÿßÿ™ ÿ∑ŸàŸÑÿßŸÜ€å\n\n` +
                   `‚ú® Ÿáÿ± ⁄ÜŸá ⁄©ŸÑŸÖÿßÿ™ ÿ≥ÿßÿØŸá‚Äåÿ™ÿ±€å ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥€åÿØÿå ÿ™ÿ≥ÿ™‚ÄåŸáÿß ÿ®Ÿáÿ™ÿ± ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ!`;
        }
        
        console.log(`üìä Test generation: ${simpleWordsCount} simple words available from ${totalWords} total words`);
        
        // Generate a simple word test from available simple vocabulary
        const test = await generateWordTest(chatId);
        if (!test) {
            return 'ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
        }
        
        // Save current test to state
        await setCurrentTest(chatId, test);
        
        // Check if the word is already marked as important
        const isWordMarked = await isWordImportant(chatId, test.wordId);
        
        return formatSingleTestResponse(test, isWordMarked);
        
    } catch (error) {
        console.error('Error generating tests:', error);
        return 'ÿÆÿ∑ÿß€å€å ÿØÿ± ÿ≥ÿßÿÆÿ™ ÿ™ÿ≥ÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.';
    }
}

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('üõë Bot is shutting down...');
    bot.stopPolling();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('üõë Bot is shutting down...');
    bot.stopPolling();
    process.exit(0);
});

console.log('‚úÖ Farsi-Dutch Telegram Bot is running!');
console.log('üì± Send messages to your bot to test it');
console.log('üõë Press Ctrl+C to stop');

/**
 * Generate a simple word test from user's vocabulary
 * Uses smart word selection: newest, middle, oldest pattern
 * Avoids repetition during active session
 * @param {string} chatId - Chat ID for session management
 * @returns {Promise<object>} - Single test object
 */
async function generateWordTest(chatId) {
    // Get next word using smart selection
    const questionWord = await getNextTestWord(chatId);
    
    if (!questionWord) {
        return null;
    }

    // Get other words for wrong options
    const otherWords = await getWordsForOptions(chatId, questionWord.id, 2);
    
    if (otherWords.length < 2) {
        // Not enough words for options
        return null;
    }

    // Only 2 test types for words
    const testTypes = [
        'dutch_to_farsi',    // ŸÖÿπŸÜ€å ⁄©ŸÑŸÖŸá ŸáŸÑŸÜÿØ€å (⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å)
        'farsi_to_dutch'     // ŸÖÿπÿßÿØŸÑ ŸáŸÑŸÜÿØ€å ⁄©ŸÑŸÖŸá ŸÅÿßÿ±ÿ≥€å (⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ®Ÿá ŸáŸÑŸÜÿØ€å)
    ];

    // Randomly pick a test type
    const testType = testTypes[Math.floor(Math.random() * testTypes.length)];

    const test = {
        id: Math.random().toString(36).substr(2, 9),
        type: testType,
        wordId: questionWord.id, // Add wordId for marking functionality
        question: '',
        correctAnswer: '',
        options: [],
        explanation: ''
    };

    // Generate wrong options from other words
    const wrongOptions = otherWords
        .map(word => testType === 'dutch_to_farsi' ? word.farsi : word.dutch);

    if (testType === 'dutch_to_farsi') {
        test.question = `ŸÖÿπŸÜ€å ⁄©ŸÑŸÖŸá ¬´${questionWord.dutch}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
        test.correctAnswer = questionWord.farsi;
        test.explanation = `⁄©ŸÑŸÖŸá ¬´${questionWord.dutch}¬ª ÿ®Ÿá ŸÖÿπŸÜ€å ¬´${questionWord.farsi}¬ª ÿßÿ≥ÿ™.`;
    } else {
        test.question = `ŸÖÿπÿßÿØŸÑ ŸáŸÑŸÜÿØ€å ⁄©ŸÑŸÖŸá ¬´${questionWord.farsi}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
        test.correctAnswer = questionWord.dutch;
        test.explanation = `⁄©ŸÑŸÖŸá ¬´${questionWord.farsi}¬ª ÿ®Ÿá ŸáŸÑŸÜÿØ€å ¬´${questionWord.dutch}¬ª ÿßÿ≥ÿ™.`;
    }

    // Mix correct answer with wrong options and shuffle
    test.options = [test.correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);

    return test;
}

/**
 * Create a diverse test question
 * @param {string} testType - Type of test
 * @param {Array} sourceData - Primary data for the test
 * @param {Array} allData - All available data for wrong options
 * @returns {Promise<object>} - Test object
 */
async function createDiverseTest(testType, sourceData, allData) {
    // Shuffle source data
    const shuffledSource = [...sourceData].sort(() => Math.random() - 0.5);
    
    for (const item of shuffledSource) {
        const test = {
            id: Math.random().toString(36).substr(2, 9),
            type: testType,
            question: '',
            correctAnswer: '',
            options: [],
            explanation: ''
        };
        
        switch (testType) {
            case 'farsi_sentence_meaning':
                if (item.fa && item.nl) {
                    test.question = `ÿß€åŸÜ ÿ¨ŸÖŸÑŸá ŸÅÿßÿ±ÿ≥€å ÿ®Ÿá ŸáŸÑŸÜÿØ€å ⁄ÜŸá ŸÖÿπŸÜÿß€å€å ÿØÿßÿ±ÿØÿü\n\n¬´${item.fa}¬ª`;
                    test.correctAnswer = item.nl;
                    
                    // Get wrong options from other Dutch sentences
                    const wrongOptions = allData
                        .filter(d => d.nl && d.nl !== item.nl && d.nl.length < 100) // Not too long
                        .map(d => d.nl)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 2);
                    
                    if (wrongOptions.length >= 2) {
                        test.options = [test.correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
                        test.explanation = `ÿ¨ŸÖŸÑŸá ŸÅÿßÿ±ÿ≥€å ¬´${item.fa}¬ª ÿ®Ÿá ŸáŸÑŸÜÿØ€å ¬´${item.nl}¬ª ÿ™ÿ±ÿ¨ŸÖŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.`;
                    }
                }
                break;
                
            case 'dutch_sentence_meaning':
                if (item.nl && item.fa) {
                    test.question = `ÿß€åŸÜ ÿ¨ŸÖŸÑŸá ŸáŸÑŸÜÿØ€å ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å ⁄ÜŸá ŸÖÿπŸÜÿß€å€å ÿØÿßÿ±ÿØÿü\n\n¬´${item.nl}¬ª`;
                    test.correctAnswer = item.fa;
                    
                    // Get wrong options from other Farsi sentences
                    const wrongOptions = allData
                        .filter(d => d.fa && d.fa !== item.fa && d.fa.length < 100)
                        .map(d => d.fa)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 2);
                    
                    if (wrongOptions.length >= 2) {
                        test.options = [test.correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
                        test.explanation = `ÿ¨ŸÖŸÑŸá ŸáŸÑŸÜÿØ€å ¬´${item.nl}¬ª ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å ¬´${item.fa}¬ª ÿ™ÿ±ÿ¨ŸÖŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.`;
                    }
                }
                break;
                
            case 'dutch_word_meaning':
                if (item.nl && item.fa) {
                    test.question = `ŸÖÿπŸÜ€å ⁄©ŸÑŸÖŸá/Ÿàÿß⁄òŸá ¬´${item.nl}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
                    test.correctAnswer = item.fa;
                    
                    // Get wrong options from other Farsi translations
                    const wrongOptions = allData
                        .filter(d => d.fa && d.fa !== item.fa)
                        .map(d => d.fa)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 2);
                    
                    if (wrongOptions.length >= 2) {
                        test.options = [test.correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
                        test.explanation = `⁄©ŸÑŸÖŸá ¬´${item.nl}¬ª ÿ®Ÿá ŸÖÿπŸÜ€å ¬´${item.fa}¬ª ÿßÿ≥ÿ™.`;
                    }
                }
                break;
                
            case 'farsi_word_meaning':
                if (item.fa && item.nl) {
                    test.question = `ŸÖÿπÿßÿØŸÑ ŸáŸÑŸÜÿØ€å ⁄©ŸÑŸÖŸá/Ÿàÿß⁄òŸá ¬´${item.fa}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
                    test.correctAnswer = item.nl;
                    
                    // Get wrong options from other Dutch translations
                    const wrongOptions = allData
                        .filter(d => d.nl && d.nl !== item.nl)
                        .map(d => d.nl)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 2);
                    
                    if (wrongOptions.length >= 2) {
                        test.options = [test.correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
                        test.explanation = `⁄©ŸÑŸÖŸá ¬´${item.fa}¬ª ÿ®Ÿá ŸáŸÑŸÜÿØ€å ¬´${item.nl}¬ª ÿßÿ≥ÿ™.`;
                    }
                }
                break;
        }
        
        // Check if we have exactly 3 options
        if (test.options.length === 3) {
            return test;
        }
    }
    
    return null;
}

/**
 * Handle test answer from callback button
 * @param {string} chatId - Chat ID
 * @param {string} selectedOption - Selected option
 * @param {object} currentTest - Current test data
 * @returns {Promise<object>} - Response object with text and keyboard
 */
async function handleTestCallbackAnswer(chatId, selectedOption, currentTest) {
    const isCorrect = selectedOption === currentTest.correctAnswer;
    
    // Update score
    const scoreData = await updateTestScore(chatId, isCorrect);
    
    // Determine test category for display
    let categoryIcon = '';
    if (currentTest.type.includes('sentence')) {
        categoryIcon = 'üìù';
    } else {
        categoryIcon = 'üî§';
    }
    
    let response = `${categoryIcon} **${currentTest.question}**\n\n`;
    
    // Show all options with indicators
    const letters = ['ÿ¢', 'ÿ®', 'ÿ¨'];
    currentTest.options.forEach((option, index) => {
        // Truncate long options for display
        let displayOption = option;
        if (option.length > 80) {
            displayOption = option.substring(0, 77) + '...';
        }
        
        if (option === selectedOption && isCorrect) {
            response += `‚úÖ ${letters[index]}) ${displayOption} ‚Üê ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ŸÖÿß (ÿØÿ±ÿ≥ÿ™)\n`;
        } else if (option === selectedOption && !isCorrect) {
            response += `‚ùå ${letters[index]}) ${displayOption} ‚Üê ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ŸÖÿß (ÿßÿ¥ÿ™ÿ®ÿßŸá)\n`;
        } else if (option === currentTest.correctAnswer) {
            response += `‚úÖ ${letters[index]}) ${displayOption} ‚Üê ÿ¨Ÿàÿßÿ® ÿØÿ±ÿ≥ÿ™\n`;
        } else {
            response += `‚ö™ ${letters[index]}) ${displayOption}\n`;
        }
    });
    
    response += `\n`;
    
    if (isCorrect) {
        response += `üéâ **ÿ¢ŸÅÿ±€åŸÜ! ÿØÿ±ÿ≥ÿ™ ÿ¨Ÿàÿßÿ® ÿØÿßÿØ€å!**\n\n`;
    } else {
        response += `üòî **ŸÖÿ™ÿßÿ≥ŸÅÿßŸÜŸá ÿßÿ¥ÿ™ÿ®ÿßŸá ÿ®ŸàÿØ!**\n\n`;
    }
    
    response += `üí° ${currentTest.explanation}\n\n`;
    response += `üìä **ÿßŸÖÿ™€åÿßÿ≤ ÿ¥ŸÖÿß:** ${scoreData.score} ÿßÿ≤ ${scoreData.total}`;
    
    // Create keyboard with word marking button and next test button
    const keyboard = {
        inline_keyboard: []
    };
    
    // Add word marking button if wordId is available
    if (currentTest.wordId) {
        const isWordMarked = await isWordImportant(chatId, currentTest.wordId);
        const markButtonText = isWordMarked ? '‚≠ê ÿ≠ÿ∞ŸÅ ŸÜÿ¥ÿßŸÜ' : '‚≠ê ŸÜÿ¥ÿßŸÜ ⁄©ÿ±ÿØŸÜ ⁄©ŸÑŸÖŸá';
        
        keyboard.inline_keyboard.push([
            {
                text: markButtonText,
                callback_data: `mark_word_${currentTest.wordId}`
            }
        ]);
    }
    
    // Add next test button
    keyboard.inline_keyboard.push([
        {
            text: 'üîÑ ÿ¢ŸÖÿßÿØŸá ÿ™ÿ≥ÿ™ ÿ®ÿπÿØ€åÿü',
            callback_data: 'start_new_test'
        }
    ]);
    
    // Clear current test
    await clearCurrentTest(chatId);
    
    return {
        text: response,
        reply_markup: keyboard
    };
}

/**
 * Handle test answer from user (text input - legacy)
 * @param {string} chatId - Chat ID
 * @param {string} userAnswer - User's answer
 * @param {object} currentTest - Current test data
 * @returns {Promise<string>} - Response message
 */
async function handleTestAnswer(chatId, userAnswer, currentTest) {
    // Check if answer matches any of the valid options (ÿ¢ÿå ÿ®ÿå ÿ¨)
    let selectedOption = null;
    const validAnswers = ['ÿ¢', 'ÿ®', 'ÿ¨', 'a', 'b', 'c', 'A', 'B', 'C'];
    const optionMap = {
        'ÿ¢': 0, 'a': 0, 'A': 0,
        'ÿ®': 1, 'b': 1, 'B': 1,
        'ÿ¨': 2, 'c': 2, 'C': 2
    };
    
    const cleanAnswer = userAnswer.trim();
    
    if (validAnswers.includes(cleanAnswer)) {
        selectedOption = currentTest.options[optionMap[cleanAnswer]];
    } else {
        // Maybe user wrote the full answer
        selectedOption = currentTest.options.find(opt => 
            opt.toLowerCase().includes(cleanAnswer.toLowerCase()) || 
            cleanAnswer.toLowerCase().includes(opt.toLowerCase())
        );
    }
    
    if (!selectedOption) {
        return 'ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ¢ÿå ÿ®ÿå €åÿß ÿ¨ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.';
    }
    
    const result = await handleTestCallbackAnswer(chatId, selectedOption, currentTest);
    return result.text; // Return only text for legacy compatibility
}

/**
 * Check if a word can be used for a specific test type
 * @param {object} word - Word object
 * @param {string} testType - Type of test
 * @returns {boolean} - Whether test can be created
 */
function canCreateTestType(word, testType) {
    switch (testType) {
        case 'dutch_meaning':
            return word.nl && word.fa;
        case 'farsi_meaning':
            return word.nl && word.fa;
        case 'synonyms_antonyms':
            return (word.synonyms && word.synonyms.length > 0) || (word.antonyms && word.antonyms.length > 0);
        default:
            return false;
    }
}

/**
 * Create a single test question
 * @param {object} word - Target word
 * @param {string} testType - Type of test
 * @param {Array} otherWords - Other words for wrong options
 * @returns {Promise<object>} - Test object
 */
async function createTest(word, testType, otherWords) {
    const test = {
        id: Math.random().toString(36).substr(2, 9),
        type: testType,
        question: '',
        correctAnswer: '',
        options: [],
        explanation: ''
    };
    
    switch (testType) {
        case 'dutch_meaning':
            test.question = `ŸÖÿπŸÜ€å ⁄©ŸÑŸÖŸá ¬´${word.nl}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
            test.correctAnswer = word.fa;
            
            // Generate wrong options from other Dutch words' Farsi meanings
            const wrongFarsiOptions = otherWords
                .filter(w => w.fa && w.fa !== word.fa)
                .map(w => w.fa)
                .sort(() => Math.random() - 0.5)
                .slice(0, 2);
            
            test.options = [test.correctAnswer, ...wrongFarsiOptions]
                .sort(() => Math.random() - 0.5);
            test.explanation = `⁄©ŸÑŸÖŸá ¬´${word.nl}¬ª ÿ®Ÿá ŸÖÿπŸÜ€å ¬´${word.fa}¬ª ÿßÿ≥ÿ™.`;
            break;
            
        case 'farsi_meaning':
            test.question = `ŸÖÿπÿßÿØŸÑ ŸáŸÑŸÜÿØ€å ⁄©ŸÑŸÖŸá ¬´${word.fa}¬ª ⁄Ü€åÿ≥ÿ™ÿü`;
            test.correctAnswer = word.nl;
            
            // Generate wrong options from other words' Dutch translations
            const wrongDutchOptions = otherWords
                .filter(w => w.nl && w.nl !== word.nl)
                .map(w => w.nl)
                .sort(() => Math.random() - 0.5)
                .slice(0, 2);
            
            test.options = [test.correctAnswer, ...wrongDutchOptions]
                .sort(() => Math.random() - 0.5);
            test.explanation = `⁄©ŸÑŸÖŸá ¬´${word.fa}¬ª ÿ®Ÿá ŸáŸÑŸÜÿØ€å ¬´${word.nl}¬ª ÿßÿ≥ÿ™.`;
            break;
            
        case 'synonyms_antonyms':
            if (word.synonyms && word.synonyms.length > 0) {
                const synonym = word.synonyms[0];
                test.question = `⁄©ÿØÿßŸÖ ⁄©ŸÑŸÖŸá ŸÖÿ™ÿ±ÿßÿØŸÅ ¬´${word.nl}¬ª ÿßÿ≥ÿ™ÿü`;
                test.correctAnswer = synonym;
                
                // Generate wrong options
                const wrongSynOptions = otherWords
                    .filter(w => w.nl && w.nl !== word.nl)
                    .map(w => w.nl)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 2);
                
                test.options = [test.correctAnswer, ...wrongSynOptions]
                    .sort(() => Math.random() - 0.5);
                test.explanation = `¬´${synonym}¬ª ŸÖÿ™ÿ±ÿßÿØŸÅ ¬´${word.nl}¬ª ÿßÿ≥ÿ™.`;
            } else if (word.antonyms && word.antonyms.length > 0) {
                const antonym = word.antonyms[0];
                test.question = `⁄©ÿØÿßŸÖ ⁄©ŸÑŸÖŸá ŸÖÿ™ÿ∂ÿßÿØ ¬´${word.nl}¬ª ÿßÿ≥ÿ™ÿü`;
                test.correctAnswer = antonym;
                
                // Generate wrong options
                const wrongAntOptions = otherWords
                    .filter(w => w.nl && w.nl !== word.nl)
                    .map(w => w.nl)
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 2);
                
                test.options = [test.correctAnswer, ...wrongAntOptions]
                    .sort(() => Math.random() - 0.5);
                test.explanation = `¬´${antonym}¬ª ŸÖÿ™ÿ∂ÿßÿØ ¬´${word.nl}¬ª ÿßÿ≥ÿ™.`;
            }
            break;
    }
    
    // Ensure we have exactly 3 options
    if (test.options.length !== 3) {
        return null;
    }
    
    return test;
}

// ============================================================================
// AUTOMATIC CONTENT GENERATION SYSTEM
// ============================================================================

/**
 * Start automatic content generation system
 * Posts educational content every 2 hours to @parsibrug channel
 */
async function startContentGeneration() {
    console.log('ü§ñ Starting automatic content generation system...');
    console.log(`üìã Content will be posted every 2 hours to ${CHANNEL_USERNAME}`);
    
    // Check and post content every 30 minutes (to ensure precise timing)
    const checkInterval = 30 * 60 * 1000; // 30 minutes
    
    setInterval(async () => {
        try {
            const posted = await contentService.checkAndPostContent(bot, CHANNEL_USERNAME);
            if (posted) {
                console.log('‚úÖ New content posted successfully');
            }
        } catch (error) {
            console.error('‚ùå Error in content generation:', error.message);
            console.error('Stack:', error.stack);
        }
    }, checkInterval);
    
    // Post initial content if needed (after 1 minute startup delay)
    setTimeout(async () => {
        try {
            console.log('üîÑ Checking for initial content post...');
            const posted = await contentService.checkAndPostContent(bot, CHANNEL_USERNAME);
            if (posted) {
                console.log('‚úÖ Initial content posted successfully');
            } else {
                console.log('‚ÑπÔ∏è  No initial content needed at this time');
            }
        } catch (error) {
            console.error('‚ùå Error in initial content posting:', error.message);
            console.error('Stack:', error.stack);
        }
    }, 60000); // 1 minute delay
}

/**
 * Handle admin content commands
 */
async function handleAdminContentCommands(msg, command, args) {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Check if user is admin
    if (userId !== config.ADMIN.USER_ID) {
        await bot.sendMessage(chatId, '‚ùå ÿß€åŸÜ ÿØÿ≥ÿ™Ÿàÿ± ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿßÿØŸÖ€åŸÜ ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ÿßÿ≥ÿ™.');
        return;
    }
    
    switch (command) {
        case '/contentstats':
            try {
                const stats = contentService.getContentStats();
                const statsMessage = `üìä **ÿ¢ŸÖÿßÿ± ÿ™ŸàŸÑ€åÿØ ŸÖÿ≠ÿ™Ÿàÿß**\n\n` +
                    `‚è∞ ÿ¢ÿÆÿ±€åŸÜ Ÿæÿ≥ÿ™: ${stats.lastPostTime}\n` +
                    `üìà Ÿæÿ≥ÿ™‚ÄåŸáÿß€å ÿßŸÖÿ±Ÿàÿ≤: ${stats.totalPostsToday}\n` +
                    `üìù ŸÜŸàÿπ ŸÖÿ≠ÿ™ŸàÿßŸáÿß€å ÿßŸÖÿ±Ÿàÿ≤: ${stats.dailyContentUsed.join(', ')}\n\n` +
                    `üìã **ÿ¢ÿÆÿ±€åŸÜ Ÿæÿ≥ÿ™‚ÄåŸáÿß:**\n` +
                    stats.lastFivePosts.map((post, i) => 
                        `${i + 1}. ${post.type} (${post.level}) - ${post.time}`
                    ).join('\n');
                
                await safeSendMessage(chatId, statsMessage, { parse_mode: 'Markdown' });
            } catch (error) {
                await safeSendMessage(chatId, `‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿ¢ŸÖÿßÿ±: ${error.message}`);
            }
            break;
            
        case '/forcepost':
            try {
                const contentType = args[0] || null;
                const level = args[1] || null;
                
                const result = await contentService.forcePostContent(bot, CHANNEL_USERNAME, contentType, level);
                
                if (result.success) {
                    await safeSendMessage(chatId, `‚úÖ ${result.message}`, { parse_mode: 'Markdown' });
                } else {
                    await safeSendMessage(chatId, `‚ùå ${result.message}`, { parse_mode: 'Markdown' });
                }
            } catch (error) {
                await safeSendMessage(chatId, `‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿßŸÜÿ™ÿ¥ÿßÿ± ÿßÿ¨ÿ®ÿßÿ±€å ŸÖÿ≠ÿ™Ÿàÿß: ${error.message}`);
            }
            break;
            
        case '/contenttypes':
            const contentTypes = contentService.contentTypes.map(ct => 
                `‚Ä¢ ${ct.type} (${ct.category}) - ÿ≥ÿ∑Ÿàÿ≠: ${ct.level.join(', ')}`
            ).join('\n');
            
            await bot.sendMessage(chatId, `üìù **ÿßŸÜŸàÿßÿπ ŸÖÿ≠ÿ™Ÿàÿß:**\n\n${contentTypes}\n\n` +
                `üí° **ÿ±ÿßŸáŸÜŸÖÿß:**\n` +
                `/forcepost [ŸÜŸàÿπ] [ÿ≥ÿ∑ÿ≠] - ÿßŸÜÿ™ÿ¥ÿßÿ± ÿßÿ¨ÿ®ÿßÿ±€å ŸÖÿ≠ÿ™Ÿàÿß\n` +
                `/contentstats - ÿ¢ŸÖÿßÿ± ŸÖÿ≠ÿ™Ÿàÿß`, 
                { parse_mode: 'Markdown' });
            break;
    }
}

// ============================================================================
// AUTO-CLEANUP SYSTEM
// ============================================================================

// Add comprehensive error handling
bot.on('error', (error) => {
    console.error('üö® Bot error:', error.message);
    console.error('Stack:', error.stack);
});

process.on('uncaughtException', (error) => {
    console.error('üö® Uncaught Exception:', error.message);
    console.error('Stack:', error.stack);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('üö® Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});

// Start automatic cleanup system
console.log('üöÄ Starting Farsi-Dutch Bot...');
// startAutoCleanup(bot); // DISABLED: Keep all user data permanently
// console.log('‚úÖ Auto-cleanup system activated');

// Start automatic content generation system
startContentGeneration();
console.log('‚úÖ Automatic content generation system activated');

module.exports = bot;